#!/usr/bin/env jruby

require 'rubygems'
require 'bundler/setup'

require 'digest/sha1'
require 'fileutils'
require 'tempfile'
require 'timeout'
require 'sequel'
require 'multi_json'
require 'securerandom'

require 'sinatra'



TMP_DIR = '/tmp/capaplan'

DB_CONNECT = "jdbc:mysql://localhost/capaplantest?user=root&password=root"
#DB_CONNECT = "jdbc:sqlite:#{TMP_DIR}/db.sqlite3"
DB_TIMEOUT = 0.1

SHA1_SIZE = { 
  '1'      => '60cacbf3d72e1e7834203da608037b1bf83b40e8',
  '10'     => '34e163be8e43c5631d8b92e9c43ab0bf0fa62b9c',
  '100'    => '5a6918eebd9d635e8f632e3ef34e3792b1b5ec13',
  '1000'   => '8fee1653e234fee8513245d3cb3e3c06d071493e',
  '10000'  => 'c2bfe67cfb2e4cac7edbb3013888abea6a123ac5',
}

SHA1_TIMEOUT = {
  '1'     => 0.001,
  '10'    => 0.01,
  '100'   => 0.01,
  '1000'  => 0.1,
  '10000' => 0.1,
}

unless File.exists?(TMP_DIR) then
  FileUtils.mkdir(TMP_DIR)
end

DB = Sequel.connect(DB_CONNECT)

unless DB.table_exists?(:testwrite)
  DB.create_table(:testwrite) do
    String :uuid, :primary_key=>true
  end
end

unless DB.table_exists?(:items) 
  DB.create_table(:items) do
    primary_key :id
    String :name
  end
end

unless DB.table_exists?(:users) 
  DB.create_table(:users) do
    primary_key :id
    String :name
  end
end

unless DB.table_exists?(:items_users) 
  DB.create_join_table(:user_id=>:users, :item_id=>:items)
end

# Precreate a bunch of filesystem data for consistent operations later.
#  - sha1 create (via buffer reads)
system("dd if=/dev/zero of=#{TMP_DIR}/1kb_zeros bs=1k count=1")          unless File.exists?("#{TMP_DIR}/1kb_zeros")
system("dd if=/dev/zero of=#{TMP_DIR}/10kb_zeros bs=10k count=1")        unless File.exists?("#{TMP_DIR}/10kb_zeros")
system("dd if=/dev/zero of=#{TMP_DIR}/100kb_zeros bs=10k count=10")      unless File.exists?("#{TMP_DIR}/100kb_zeros")
system("dd if=/dev/zero of=#{TMP_DIR}/1000kb_zeros bs=10k count=100")    unless File.exists?("#{TMP_DIR}/1000kb_zeros")
system("dd if=/dev/zero of=#{TMP_DIR}/10000kb_zeros bs=10k count=1000")  unless File.exists?("#{TMP_DIR}/10000kb_zeros")

KB_DATA_BLOCK = File.read("#{TMP_DIR}/1kb_zeros")

#---------

configure do
  mime_type :plain, 'text/plain'
  set :server, 'puma'
  set :port, 9595
end

get '/' do
  "Capaplan Capacity Planner\n  /status - give status"
end

get '/status' do
  "OK"
end

get '/load/cpu/sha1' do
  # compute the SHA1 of a 1mb of zeros
  # combined with buffer cache, this is essentially a CPU-only operation
  #  - though do we have stat() to content with?
  hex = ''
  size    = params[:size] || '1000'
  timeout = params[:timeout].to_f || SHA1_TIMEOUT[size].to_f

  begin 
    Timeout.timeout(timeout) {
      hex = Digest::SHA1.file("#{TMP_DIR}/#{size}kb_zeros").hexdigest
    }
  rescue => e
    puts "Timeout executing SHA1 (timeout=#{timeout}) error='#{e.message}'"
    halt 500
  end

  if ( hex != SHA1_SIZE[size] ) then
    puts "SHA1 checksum does not match! (#{hex})"
    halt 500
  end

  "OK"

end

post '/load/disk/write' do
  size = params[:size].to_i || 1024  # num kbytes to write
  data = ''
  file = Tempfile.new('write_test')
  puts "writing to #{file.path}"
  size.times { |n| 
    file.write(KB_DATA_BLOCK)
  }
  file.close(unlink_now=false)
  file.unlink unless params[:unlink]
  "OK: #{size}KiB written" 
end


post '/load/db/write' do

  timeout = params[:timeout].to_f || DB_TIMEOUT.to_f

  begin 
    Timeout.timeout(timeout) {
      # code goes here
      uuid = SecureRandom.uuid
      DB.run("insert into testwrite values ('#{uuid}')")
    }
  rescue => e
    puts "Timeout executing /db/write (timeout=#{timeout}) error='#{e.message}'"
    halt 500
  end

  "OK"
end

post '/control/shutdown' do
  exit!
end

post '/control/reloadconfig' do
  read_configuration
end

get '/load/noop/simple' do
  # basic minimal load result - pretty much return 200.
  # this is useful for comparing against raw application server performance
  # (to calculate ruby/sinatra overhead)
  "OK"
end

error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].name
end

def read_configuration 
  "OK"
end

# vim: et ts=2 sw=2

